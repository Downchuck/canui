// $Id$

canui (canvas UI) is a generic user interface library with several
predefined widgets and layout managers.


1 Summary
======================================================================
It started as a ui framework for a game I am working on, but it
grew to a point where I think it might be useful to others. It is
developed on firefox 5, but I regularly have a look at chrome.

This is a list of the available base classes:

control
  this is the base class for all the widgets. User-defined controls
  also can be created.

container
  this is the base class for all the controls that can have children.
  User-defined containers can also be created.


This is a list of the available controls:

button
  this is a regular button that fires a signal when clicked

image
  takes an Image object and draws it. It can also take a second image
  as an overlay. It handles grayscale images automatically when
  disabled.

label
  can take a caption and an image.

list
  a scrollable list of items with columns

line
  a simple horizontal line
  
menu
  list of buttons that displays menus and submenus on click

panel
  a simple container with a background color

scrollbar
  a slider with up/down-left/right buttons

scroller
  a panel that will always give its child its best dimension, but will
  clip it and allows scrolling with scrollbars
  
slider
  a panel with a thumb that can be moved horizontally or vertically
  
textbox
  allows entering a single line of text. Supports selection and the
  usual caret movement.

tooltip
  can be attacked to any control, will be displayed when the mouse
  stays still for a short time hover the control.


The top level control will always be a root_panel. It handles all the
mouse and keyboard events and will redraw itself when needed

These are the available layout managers. They are based on the layout
managers in the java swing library.

absolute_layout
  no management, uses the positions given by the user

border_layout
  has 4 sides (left, top, right and bottom), plus a center. The sides
  will use the preferred size of the controls while the center control
  will take all the remaining space.
  
grid_layout
  lays out the controls in rows of X controls, where X is specified by
  the user.
  
horizontal_layout
  lays out the controls in a horizontal line one after the other,
  respecting the preferred sizes
  
vertical_layout
  lays out the controls in a vertical line one after the other,
  respecting the preferred sizes


2 Usage
======================================================================

2.1 The root panel

The root panel is where it all starts. It needs the canvas element to
work on and its dimension.

Everything (todo: no, only the controls) is in the 'ui' namespace.

  <script type="text/javascript">
  $(function()
  {
    var rp = new ui.root_panel($("#canvas"), new dimension(200, 200));
  });
  </script>
  
  <canvas id="canvas" tabindex="1"></canvas>
  
The <canvas> needs a tabindex attribute for the focus to work
correctly.

The root panel will register mouse, keyboard and focus events on the
canvas and window. It will also start a timer (50ms) that will check
whether it needs to redraw or not. Each control will mark itself as
dirty when it changes.

Everything is currently redrawn any time a control is dirty. There is
no way to only redraw the offending widgets, although this may come
in a future version. Even for complex interfaces the redraw time is
usually under 40ms.

Some of the events are registered on the window so that capturing the
mouse is possible. For example, pressing a button and holding down the
left mouse button captures the mouse. Moving away from the button or
the browser window will still register the left mouse button release.


2.2 Layouts

canui manages the position of controls automatically with layouts.
Their name and behaviour somewhat resemble those in the java swing
library (although I did it from memory, it's been a while.)

Layouts can be set when containers are created:

  var p = new ui.panel(new ui.border_layout());

or afterwards:

  p.layout(new ui.border_layout());

The default layout for all containers is vertical_layout. The layout
cannot be changed while the container has children. This is because
some layouts may need additional information about the children (such
as the sides for border_layout.)


3 Controls
======================================================================

In the following examples, 'rp' is a always a root_panel.

3.1 button

The button can either manage its label (with caption()) or use any
kind of control as its child (with label().) It supports the usual
interactions:

  . hovering it changes its color
  . pressing the left mouse button will show it as being pressed,
    unless the mouse is not hovering anymore
  . releasing the left mouse button while hovering will fire a
    'clicked' signal

Options:
    
Example:

  function on_click()
  {
  }
  
  function f(rp)
  {
    // regular button, calls on_click
    rp.add(new ui.button({caption: "foo", clicked: on_click}));
    
    // button, also calls on_click
    var b = new ui.button({caption: "bar"});
    b.clicked.add(on_click);
    rp.add(b);
    
    // changes the caption
    b.caption("frob");
  }

3.2 image

This is a simple control that displays an Image object. It can also
have a second image that will be overlaid on the first, with a
possibly different alpha value.

This control currently assumes the given Image has already been
loaded. It will fail catastrophically if it hasn't. todo: fix that.
The require_loaded() helper can be used to create the control only
when image has been loaded.

It will automatically create grayscale versions of the images that
will be used when the control is disabled. Whether the overlay is
also grayed depends on the options.

Options:
  . margin (positive integer), default: 5
    space around the image

  . halign (left, center, right), default: center
    horizontal alignement of the image

  . valign (top, center, bottom), default: center
    vertical alignment of the image

  . overlay_halign (left, center, right), default: center
    horizontal alignment of the overlay (if present) over the main
    image (not the available space, ignored if both images have the
    same size)

  . overlay_valign (top, center, bottom), default: center
    vertical alignment of the overlay (if present) over the main
    image (not the available space, ignored if both images have the
    same size)

  . overlay_grayed (true/false), default: true
    when the control is disabled, also gray out the overlay

  . alpha ([0.0, 1.0]), default: 1.0
    transparency of the overlay


Example:

  // an image control with image.png on it
  //
  function f(rp)
  {
    var i = new Image();
    i.src = "image.png";
    
    require_loaded(i, function()
      {
        rp.add(new ui.image(i));
      });
  }

  // an image control with image.png and overlay.png on it; this
  // assumes 'i' and 'o' are two already loaded images
  //
  function g(rp, i, o)
  {
    // the image will be aligned to the left side of the control (if
    // the control is bigger than the image); disabling the control
    // will show a grayed image 'i', but a full color 'o'; the overlay
    // will be drawn at 0.5 alpha
    
    rp.add(new ui.image(i, o,
      {halign: left, overlay_grayed: false, alpha: 0.5}));
  }

3.4 label

Contains both a caption and an image. The image can be either at the
left or right side of the caption. Either or both can be omitted.

The label will automatically wait for the Image to be loaded before
showing it. (todo: no, the grayscale generation will fail)

Options:
  . image_align (right, left), default: right
    the position of the image relative to the caption
    note: ignored if there's no caption

  . halign (left, center, right), default: left
    horizontal position of the rectangle bounding both the image and
    the caption

  . valign (top, center, bottom), default: center
    vertical position of the rectangle bounding both the image and
    the caption

  . padding (positive integer), default: 4
    space between caption and image
    note: ignored if either caption or image is missing

  . color (color object), default: ui.theme.text_color()
    text color

Example:

  function f(rp)
  {
    // label with a simple caption
    rp.add(new ui.label("caption"));
    
    // label with an image on the left side of the caption and both
    // aligned to the top of the control
    var i = new Image;
    i.src = "image.png";
    
    rp.add(new ui.label("caption", i,
      {image_align: left, valign: top}));
  }

3.5 line

This is just a horizontal line.

Options:
  . size (positive integer), default: 1
    height in pixels of the line

  . margin (positive integer), default: 5
    space around the line

  . color (color object), default: black
    color of the line
    
Example:

  function f(rp)
  {
    // two pixel high line, with 10 pixels of margin on each side
    rp.add(new ui.line(2, {margin: 10}));
  }
  

3.6 list

This is a list of items with columns. It only supports "details" view
for now, with single and multiple selections.

Options:
  . item_height (positive integer), default: g_line_height + 4
    height in pixels of an item; the text will be vertically
    centered

  . padding (positive integer), default: 5
    space on the left side of the items

  . column_resize (none, content, header, auto), default: auto
    specifies how columns are resized: "content" uses the width of
    the largest item and therefore might be slow for very long
    lists; "header" uses the width of the column caption; "none"
    requires the user to set the width manually; "auto" uses the
    largest between content and header

  . show_header (true/false), default: true
    whether the column headers should be visible

  . expand_header (true/false), default: false
    whether the last column should be expanded to take the remaining
    horizontal space

  . item_scroll (true/false), default: false
    whether scrolling is per-pixel or per-item
  
Example:
  
  function f(rp)
  {
    var list = new ui.list();
    list.add_column("col 1");
    list.add_column("col 2");
    
    for (var i=0; i<10; ++i)
      list.add_item(["item " + i, "subitem " + 1]);
    
    rp.add(list);
  }


3.7 panel

This is a container with a background. It is mainly used when multiple
layouts are needed.

Options:
  none
  
Example:
  
  function f(rp)
  {
    // a panel with a button in it
    var p = new ui.panel();
    p.add(new ui.button({caption: "foo"}));
    
    // a panel within a panel with different layouts
    //
    // (spacing is exaggerated)
    // +---root_panel-----------------------------------+
    // |                                                |
    // |  +---p1-(border_layout)---------------------+  |
    // |  |                                          |  |
    // |  |  +---p2-(horizontal_layout)-----------+  |  |
    // |  |  |                                    |  |  |
    // |  |  |  +button-+  +button-+              |  |  |
    // |  |  |  |  foo  |  |  bar  |              |  |  |
    // |  |  |  +-------+  +-------+              |  |  |
    // |  |  |                                    |  |  |
    // |  |  +------------------------------------+  |  |
    // |  |                                          |  |
    // |  |  +---button---------------------------+  |  |
    // |  |  |                                    |  |  |
    // |  |  |                                    |  |  |
    // |  |  |                 frob               |  |  |
    // |  |  |                                    |  |  |
    // |  |  |                                    |  |  |
    // |  |  +------------------------------------+  |  |
    // |  |                                          |  |
    // |  +------------------------------------------+  |
    // |                                                |
    // +------------------------------------------------+
    var p1 = new ui.panel(new ui.border_layout());
    var p2 = new ui.panel(new ui.horizontal_layout());
    
    p2.add(new ui.button({caption: "foo"}));
    p2.add(new ui.button({caption: "bar"}));
    
    p1.add(p2, ui.sides.top);
    p1.add(new ui.button({caption: "frob"}), ui.sides.center);
    
    rp.add(p1);
  }


3.8 scrollbar

This is a slider (3.10) with up/down or left/right buttons. A scroller
(3.9) can be used to automatically manage scrolling a child control,
but standalone scrollbars can also be used. The list control (3.6)
uses them.

  function f(rp)
  {
    f.layout(new ui.border_layout());

    var sb = new ui.scrollbar();

    // the value will be constrained within the limits; this also
    // determines the size of the thumb (see 3.10)
    sb.limits(0, 30);
    sb.value(12);

    // this determines the amount scrolled by clicking the empty
    // space around the thumb
    sb.page_size(5);

    // fired when the value changes
    sb.changed.add(function(v)
      {
        alert("value is " + v);
      });

    rp.add(sb, ui.sides.right);
  }


3.9 scroller

This is a panel with scrollbars. Its only child will always have its
preferred size and will be moved around when scrolling.

A scroller uses sliders (3.10) and special buttons that support holding
them down to continuously scroll.

Options:
  none
  
Example:
  
  function f(rp)
  {
    // assumes that the image is larger than the canvas
    var i = new Image();
    i.src = "large_image.png");
    
    require_loaded(i, function()
      {
        var s = new ui.scroller();
        s.add(new ui.image(i));
        
        rp.add(s);
      });
  }


3.10 slider

This is a thin panel with a button that can be moved around,
constrained to the panel. It also supports clicking in the empty
spaces around the thumb to move it faster. It will fire the changed()
signal when the value changes.

A slider has a value that is between user-defined limits. The limits
are unimportant from the slider's point of view, it only scales the
value.

While dragging the thumb, it will reset to its original value if the
mouse moves too far.

The thumb will also resize itself proportionally depending on the
limits and the size of the slider. In this mode, the slider uses the
range within the limits (max minus min) to shrink the thumb: the
range is the number of pixels to shrink the thumb by, up to the
minimum size of the thumb. Therefore, a limit of 10,20 will leave
10 pixels for the thumb to move around.

Options:
  . orientation (horizontal, vertical), default: horizontal
    whether the slider is horizontal or vertical

  . outside_limit (positive integer), default: 130
    the amount of pixels the mouse can move away from the thumb
    before it resets

  . page_size (positive integer), default: 1
    the value increment while the mouse is held down in the empty
    space

  . proportional (true/false), default: false
    whether the thumb size should be proportional to the limits
    and slider size

Example:
  
  function (rp)
  {
    // horizontal slider
    var s = new ui.slider();
    s.limits(10, 50);
    
    rp.add(s);
  }


3.11 textbox

Textboxes are hard. There's even a long section from whatwg saying
that "authors should avoid implementing text editing controls using
the canvas element. Doing so has a large number of disadvantages."
[whatwg-best]

However, most of the disadvantages are implemented, except for the
native stuff:

  . copy/paste: possible within the canvas, bespin uses flash to 
    access the system clipboard
  . spell-checking: I consider this to be candy, but it is a nice
    thing to have
  . native keyboard shortcuts: I don't consider this to be
    particularly significant
  
Other things are not specific to textboxes:
  . page-wide text search: nice to have, but that's a problem with
    text on canvas in general, not only textboxes.
    
    whatwg says that "a future version of the 2D context API may
    provide a way to render fragments of documents, rendered using
    CSS, straight to the canvas." [whatwg2] This may perhaps allow the
    browser to recognize the text, but I doubt it.
    
    This is also a problem with images in browsers, or more generally
    any kind of application that doesn't use standard widgets (such
    as games.)
    
  . text services and IMEs, bidirectional text, accessibility:
    basically any kind of i18n or accessibility. That would indeed
    be nice and, although parts of it may be implemented, _that_ would
    be hard work.
    
I do not consider those to be show-stoppers, but merely limitations
inherent to having a browser in a sandbox. Some are not implemented
yet, but not for technical reasons; they will be available eventually:

  . drag-and-drop
  . multiline editing
  . undo/redo: not system wide, but available within the textbox

The rest works fine:

  . mouse placement of the caret
  . keyboard movement
  . scrolling (todo)
  . selection

Options:
  none
  
Example:
  
  function f(rp)
  {
    rp.add(new ui.textbox("initial text"));
  }
  

3.12 tooltip

A tooltip is nothing special, except that it has a yellow background
and borders. Every control can have a tooltip (set by calling
tooltip() on it), but the control given can be anything. It will be
shown at the mouse position after a short delay if the the mouse
stands still.

Options:
  none
  
Example:

  function f(rp)
  {
    var lb = new ui.label("a label");
    lb.tooltip(new ui.tooltip("text"));
    
    rp.add(lb);
  }

3.13 control and container base classes

All controls inherit from the 'control' class, which has some member
functions of its own. For example, it allows for changing the mouse
cursor while hovering the control, changing the font, setting options,
disabling, etc. It also has hooks for derived classes, such as
on_keyup() or on_focus().

All containers (such as panels) inherit from the 'container' class.
A container has a layout manager and can add or remove children.

Every control has what is called its 'best dimension' which is
respected as much as possible by the layout managers. It is sometimes
not possible (such as when a control would overflow its container) or
not used (such as the center part of a border_layout.)

The best dimension of a control depends on its content: a label will
return the size of the string plus its margins and an image will
return the size of the image plus its margins.


4 Layouts
======================================================================

There are several layout managers that will position and resize
children in different ways.

Layouts usually ask all their children for their best dimension,
fiddles with them and returns the dimension needed to accommodate all
the children.

4.1 absolute_layout

This layout won't touch its children at all. They must be positioned
and dimensioned manually with bounds() or some equivalent member
function.

Because this layout doesn't move or resize children, its preferred
size must be set manually with set_best_dimension().

Options:
  none
  
Example:

  function f(rp)
  {
    var p = new ui.panel(new ui.absolute_layout());
    
    // without this, 'p' would report that its best dimension is 0x0
    p.layout().set_best_dimension(new dimension(50, 50));
    
    var b = new ui.button();
    b.bounds(new rectangle(20, 20, 42, 19));
    
    p.add(b);
  }

4.2 border_layout

This layout has four sides plus the center. The sides will give their
child their best dimension and the center control will take the
remaining space.

It tries to be somewhat smart with the center control: if it exceeds
its maximum dimension, the excess will be redistributed to the sides
(in which case they won't have their best dimension anymore.) However,
the combination of the size of the container and the control's best
dimension might give unexpected results if the controls need strict
dimensions.

Options:
  . margin (positive integer), default: 0
    space between the borders of the container and the controls

  . padding (positive integer), default: 5
    space between an area in which there is a control and the center
    
Example:

  function f(rp)
  {
    var p = new ui.panel(new ui.border_layout());

    
    // +--------------------------------------------+
    // |                 +-----+                    |
    // |                 | top |                    |
    // |                 +-----+                    |
    // |        +-------------------------+         |
    // |+------+|                         |+-------+|
    // || left ||         center          || right ||
    // |+------+|                         |+-------+|
    // |        +-------------------------+         |
    // |                +--------+                  |
    // |                | bottom |                  |
    // |                +--------+                  |
    // +--------------------------------------------+
    
    p.add(new ui.label("top"), ui.sides.top);
    p.add(new ui.label("left"), ui.sides.left);
    p.add(new ui.label("bottom"), ui.sides.bottom);
    p.add(new ui.label("right"), ui.sides.right);
    p.add(new ui.center("center"), ui.sides.center);
    
    rp.add(p);
  }

  
4.3 grid_layout

This layout arranges its children in rows of X controls with padding
between them. The height of a row is normally the height of its
largest control, giving uneven rows. However, if the option
'same_size' is given, all the rows have the height of the largest
control among all the children. In any case, all the children have the
same width, which is the container's width (minus the margin and
padding) divided by the number of controls on a line.

Options:
  . same_size (true/false), default: false
    use the height of the highest control for every control

  . margin (positive integer), default: 0
    space between the borders of the container and the controls

  . hpadding (positive integer), default: 0
    horizontal space between two children
   
  . vpadding (positive integer), default: 0
    vertical space between two children
 
  . padding (positive integer), default: none
    sets both hpadding and vpadding to the given value

Example:
  
  function make_panel(opts)
  {
    // two child per row
    var p = new ui.panel(new ui.grid_layout(2, opts));
    
    p.add(new label("single line"));
    p.add(new button("button"));
    p.add(new label("on\nthree\nlines"));
    p.add(new button("button"));
    
    return p;
  }
  
  function f(rp)
  {
    // +---------------------------------+
    // | +-------------+ +-------------+ |
    // | | single line | |    button   | |
    // | +-------------+ +-------------+ |
    // | +-------------+ +-------------+ |
    // | |     on      | |             | |
    // | |    three    | |    button   | |
    // | |    lines    | |             | |
    // | +-------------+ +-------------+ |
    // +---------------------------------+
    rp.add(make_panel({}));
    
    // +---------------------------------+
    // | +-------------+ +-------------+ |
    // | |             | |             | |
    // | | single line | |    button   | |
    // | |             | |             | |
    // | +-------------+ +-------------+ |
    // | +-------------+ +-------------+ |
    // | |     on      | |             | |
    // | |    three    | |    button   | |
    // | |    lines    | |             | |
    // | +-------------+ +-------------+ |
    // +---------------------------------+
    rp.add(make_panel({same_size: true}));
  }

  
4.4 horizontal_layout

Lays out its children one next to the other, always respecting their
best width. This may overflow the container (todo: and probably
break in the process)

There are several alignment options and two ways of deciding the
height of the controls.

The control's height is normally its preferred height. However, if
'same_size' is given, the height will be that of the largest control.
If 'expand' is given instead, the height will be that of the container
(minus the margin, etc.) Obviously, 'same_size' is ignored with
'expand'.

The controls may be aligned horizontally on the left side, center or
right side:

  left:
  +-------------------------------------+
  | +--------+ +--------+               |
  | | label1 | | label2 |               |
  | +--------+ +--------+               |
  +-------------------------------------+

  center:
  +-------------------------------------+
  |        +--------+ +--------+        |
  |        | label1 | | label2 |        |
  |        +--------+ +--------+        |
  +-------------------------------------+

  right:
  +-------------------------------------+
  |                +--------+ +--------+|
  |                | label1 | | label2 ||
  |                +--------+ +--------+|
  +-------------------------------------+

The valign option has the same behaviour, but vertically:

  top:
  +-------------------------------------+
  | +--------+ +--------+               |
  | | label1 | | label2 |               |
  | +--------+ +--------+               |
  |                                     |
  |                                     |
  |                                     |
  |                                     |
  +-------------------------------------+

  center:
  +-------------------------------------+
  |                                     |
  |                                     |
  | +--------+ +--------+               |
  | | label1 | | label2 |               |
  | +--------+ +--------+               |
  |                                     |
  |                                     |
  +-------------------------------------+
  
  bottom:
  +-------------------------------------+
  |                                     |
  |                                     |
  |                                     |
  |                                     |
  | +--------+ +--------+               |
  | | label1 | | label2 |               |
  | +--------+ +--------+               |
  +-------------------------------------+

The valign option is ignored when 'expand' is given, since the
controls take all the available height.

  
Options:
  . expand (true, false), default: false
    controls will expand to the height of the container instead of
    using their preferred height

  . same_size (true, false), default: false
    controls will have the height of the highest instead of their
    preferred height
    note: ignored with expand

  . halign (left, center, right), default: left
    the rectangle bounding all the controls will be aligned to the
    left, center or right of the container

  . valign (top, center, bottom), default: top
    all controls will be aligned to the top, center or bottom of the
    container
    note: ignored with expand

  . margin (positive integer), default: 0
    space between the borders of the container and the controls

  . padding (positive integer), default: 5
    space between each control

Example:

  function f(rp)
  {
    var p = new ui.panel(new ui.horizontal_layout({halign: "center"));
    
    p.add(new ui.label("label1"));
    p.add(new ui.label("label2"));
    
    rp.add(p);
  }

  
4.5 vertical_layout

See 4.4, but with 'width' and 'height' reversed.



5 Utilities
======================================================================

5.1 geometry

There are several classes that are used throughout canui:

  . point (x, y)
  . dimension (w, h)
  . rectangle (x, y, w, h)

These are self-explanatory.


5.2 graphics

The 'color' class has r, g, b and a values between 0.0 and 1.0. There
is also several helper functions that wrap common graphical
operations, such as outline_rect() or fill_rect().

Playing with text is somewhat hard, since there is no reliable way
of getting the bounding rectangle of a particular string and font.
measureText() returns the width, but the text may "spill out of the
[...] width returned by measureText()"[whatwg-canvas]. There is no way
to get any kind of height information.

canui hardcodes a line height of 16 pixels and a spacing between two
lines of 3 pixels. These seem to be correct for both firefox and
chrome. ymmv.

create_grayscale() takes an Image object, creates a temporary canvas,
draws the image, gets the pixels, converts them to a light grayscale
and returns a new Image with that data. It is used by the labels so
that images are automatically grayed when the control is disabled.


5.3 utility

There are several helper classes and functions used throughout canui.

  . font
    This has the font family, size and some css attributes, such as
    bold and italic.
   
  . theme
    This is currently underused, but the plan is to put all the color
    and size information in there. 

    The controls currently have a classic Windows look, which was
    the intention, as I mostly run Windows 7 with the classic look.
    Most of the metrics and behaviour is based on Windows 7.
  
  . bind and mem_fun
    The former can bind the arguments of a function and the latter
    makes sure a particular member function is called on the right
    object.
    
      function a()
      {
        this.frob = function()
        {
        }
      }
      
      function b(a, b)
      {
        console.log(a + b);
      }
      
      var o = new a();
      var f = mem_fun('frob', o);
      f();    // calls o.frob()
  
      f = bind(b, 3, 5);
      f();    // logs 8

    These are used heavily with signals.
    
  . assert
    This will break in a debugger (if present) if the given value is
    false. There are lots of assertions throughout canui, such as for
    making sure things have the right type. I am not fond of weakly-
    typed languages.
    
  . signal
    A signal is a container of functions (slots) that are called when
    the signal is fired. This is used for callbacks, such as when a
    button is clicked:
    
      function f1(a)
      {
        console.log(a);
      }
      
      function f2(a)
      {
        console.log(a);
      }
      
      
      var s = new signal();
      s.add(f1);
      s.add(f2);
      
      s.fire(42);  // logs 42 twice
      
    A slot can return a strict false to get detached automatically.
    Returning anything else (or nothing) will keep the slot attached.
      
  . make_enum()
    There are several 'enumerations' in canui that are created with
    this function. It takes an array of strings and returns an object
    with "string: n", where n is an increasing integer value. This
    mimics the behaviour of enums in most other languages.
  


6 Custom controls
======================================================================

A custom control can either be derived from 'control' or 'container'
depending on whether you need children or not.

All the member functions in the control class can be overriden. Unless
the default behaviour needs to be avoided, the base class versions
should always be called. There are cases where it is pretty much
mandatory, such as in draw() where control__draw() clears the dirty
flag. Without it, the canvas would continually redraw itself.

These are the member functions that are most often overriden. In the
following, 'mp' is always the mouse coordinates relative to the
control.

  best_dimension()
  returns the best dimension for this control. The container base
  class will ask the layout manager for its best dimension, which is
  based on the layout itself and the dimensions of the children.

  a custom control should return the dimension it needs to display
  itself properly.

  on_mouse_move(mp)
  called when the mouse moves over the control, or anywhere if the
  control has captured the mouse

  on_mouse_left_down(mp)
  called when the mouse left button is pressed over the control, or
  anywhere if the control has captured the mouse

  on_mouse_left_up(mp)
  called when the mouse left button is released over the control, or
  anywhere if the control has captured the mouse

  on_double_click(mp)
  called when the mouse left button is double clicked over the
  control, or anywhere if the control has captured the mouse.

  on_mouse_enter(mp)
  called when the mouse moves over the control, but was previously
  over a different control

  on_mouse_leave()
  called when the mouse moves away from the control

  on_focus()
  called when the left mouse button is pressed for the first time
  while over the control; this gives the focus to the control

  on_blur()
  called when the left mouse button is pressed on another control and
  this control had the focus

  on_keypress(c)
  called when a key on the keyboard is pressed, or at regular
  intervals when the key is kept pressed; 'c' is the key code. This
  is not called for control keys, such as the arrow keys.

  on_keydown(c)
  called when a key on the keyboard is pressed, or at regular
  intervals when the key is kept pressed; 'c' is the key code. This
  is only called for control keys, such as the arrow keys.

  on_keyup(c)
  called when a key on the keyboard is released; 'c' is the key code.
  This is called for all keys.

  on_mouse_scroll(v)
  called when the mouse wheel is turned over a control, or anywhere
  if the control has captured the mouse; 'v' is a normalized value
  where 1 is a full tick.

  on_bounds_changed()
  called when the bounds of the control (position or dimension)
  changed

  draw(c)
  called when the control needs to redraw itself; 'c' is the canvas
  context. Inside draw(), the context has been transformed so that
  coordinates are relative to the parent and clipped to the parent's
  bounds. Since bounds are always relative to the parent,
  self.bounds() can be used directly as the rectangle in which to
  draw.

  typename()
  debug, should return a meaningful name for this control; this is
  used in dump() for example, to display the control hierarchy

Example:

  // a 20x20 control (when possible) that fills itself with blue
  //
  function c()
  {
    ui.inherit_control(this);

    self.best_dimension = function()
    {
      return new dimension(20, 20);
    };

    self.draw = function(context)
    {
      self.control__draw(context);

      fill_rect(context, new color().blue(), self.bounds();
    };
  }

  function f(rp)
  {
    rp.add(new c());
  }


7 Creating an interface
======================================================================

There are two ways to create an interface: using javascript to create
the dom or using html tags that are parsed by canui. As with most
things, the former is more explicit, complicated and ugly, but is
more flexible; the latter is simpler and (arguably) more elegant, but
will need to be complemented by javascript.

The following creates the root panel with a label and a textbox,
using javascript:

  function f()
  {
    var rp = new ui.root_panel({
      canvas: $("#canvas-id"),
      dimension: new dimension(200, 200),
      layout: new ui.horizontal_layout()
    });

    rp.add(new ui.label({caption: "Name:"}));
    rp.add(new ui.textbox({text: "here"}));
  }

This assumes there's a canvas tag somewhere:

  <canvas id="canvas-id"></canvas>

The following creates the same structure, but with html tags

  <div id="ui">
    <div data-type="root_panel"
         data-layout="new ui.horizontal_layout()"
         width="200" height="200">
      
      <div data-type="label">Name:</div>
      <div data-type="textbox">here</div>
    </div>
  </div>

The canvas element itself is not needed, but the following javascript
code is:

  function f()
  {
    var rp = ui.create_root_panel(document.getElementById("ui"));
  }


7.1 Javascript

todo


7.2 Html

canui uses the html5 'data' attribute [w3c-data] where custom
attributes are allowed as long as they start with "data-", such as
"data-type".

Browsers are supposed to implement a 'dataset' property for element
objects, but most do not at the moment. Therefore, canui uses the
simple getAttribute() when 'dataset' is undefined.

The tag name of the element matters not, as long as it can have
children. <div> is used in this document and examples because it is
short.

Using html tags, the structure of the interface (as well as a few
cosmetic options) can be specified directly. However, for any kind
of interaction, javascript is needed. Ids may be assigned to controls
and used with root_panel.find_id():

  <div id="ui">
    <div data-type="root_panel" width="200" height="200">
      <div id="label" data-type="label"></div>
    </div>
  </div>

  // ...
  function f()
  {
    var rp = ui.create_root_panel(document.getElementById("ui"));
    rp.find_id("label").caption("this is a label");
  }

The root element, here named "ui", serves only as a top level. Its
id is irrelevant. After creating the structure, canui will remove that
element (and its children) from the dom and replace it with a canvas
element.

When errors are found in the structure (such as having a child element
inside a control that is not a container), the top level element (here
"ui") is replaced by a red string with the error message instead of a
canvas.

These are the recognized attributes:

  data-type
  The type of the control to create. For a data-type "x", canui will
  try to do a "new ui.x()". Invalid if the type doesn't exist.

  id
  The id of the control in the structure. Can be empty.

  data-layout
  This string is eval'd and passed to container.layout(). Invalid if
  the control is not a container.

  data-options
  This must be a JSON structure. It is eval'd and passed to
  control.options().

These are the recognized events.

  onclick
  This string is eval'd and added to the 'clicked' signal of the
  control. Invalid if the control doesn't have that signal.

  onchange
  This string is eval'd and added to the 'changed' signal of the
  control. Invalid if the control doesn't have that signal.

Note that the string in an event is eval'd and must evaluate to a
function that will be from the signal. Therefore,

  onclick="f()"

will eval "f()" and add its return value to the signal. To call "f"
when something is clicked, do

  onclick="f"

Finally, all the text between tags is trimmed and passed to the
caption() member function of the control, if not empty. If there is
a non-whitespace text as a child element of a control and that control
has no caption() member function, the structure is ill-formed:

  <div data-type="textbox">text in textbox</div>
  <div data-type="image">invalid, image doesn't have caption()</div>


8 Internals
======================================================================

canui uses some kind of inheritance where member functions are
prefixed when the class name. Each base class has a "vtable" at the
end, so that these function may be overridden by derived classes.

  function inherit_base(self)
  {
    self.base__frob = function()
    {
      console.log("base__frob");
    };
    
    self.frob = self.base__frob;
  }
    
  function derived()
  {
    inherit_base(this);
    
    this.derived__frob = function()
    {
      this.base__frob();
      console.log("derived__frob");
    }
    
    this.frob = this.derived__frob;
  }
  
  var d = new derived();
  
  // base__frob
  // derived__frob
  d.frob();

  
9 References
======================================================================

[whatwg-canvas]
http://www.whatwg.org/specs/web-apps/current-work/multipage/
the-canvas-element.html
         
[whatwg-best] 
http://www.whatwg.org/specs/web-apps/current-work/multipage/
the-canvas-element.html#best-practices

[w3c-data]
http://www.w3.org/TR/html5/elements.html#
embedding-custom-non-visible-data-with-the-data-attributes

eof
